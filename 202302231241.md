---
tags: [database, programming-language]
---

# Structured Query Language (SQL)

SQL consists of [Data-Definition Language (DDL)](202302171848.md),
[Data-Manipulation Language (DML)](202302171843.md), integrity constraints, view
definition, transaction control, embedded SQL and dynamic SQL, and
[Authorisation](202210221159.md). It is widely used in [relational database](202302101331.md).

The basic types for SQL are `char(n)`, `varchar(n)`, `int`, `smallint`,
`numeric(p,d)`, `real`, `double precision`, and `float(n)` where $n$ denotes
the length or the least precision of the type, $p$ denotes the precision of the
digits, and $d$ denotes the number of digits right of the decimal point. There
is a special type called `null` that indicates an absent value, but it is
generally not recommended having such value in the [Database](202302101139.md).

To create a table (or relation) in SQL-based database, execute the `create
table` command with the name of the table including its desired column and their
corresponding types. Optionally, integrity constraint, such as `primary key`
(unique and cannot be empty), `foreign key ... references ...` (See
[referential integrity constraint](202302101331.md)), and `not null`, can be
enforced on an attribute (column). The following SQL codes shows such use case:

```sql
create table instructor
  (ID varchar(5),
   name varchar(20) not null,
   dept_name varchar(20),
   salary numeric(8,2),
   primary key (ID),
   foreign key (dept_name) references department);
```

We can insert an entry into the relation with the following codes:

```sql
insert into instructor
  values(10211, 'Smith', 'Biology', 66000);
```

Or with subquery:

```sql
insert into instructor
  select ID, name, dept_name, 100000
  from student
  where tot_cred > 100;
```

We can update entries in a relation (may be aided with `where` clause) with the
following codes:

```sql
update instructor
set salary = salary * 1.05
where salary <= 100000;
```

If there are several cases to handle, we can use the `case` and `end` clause
instead like below:

```sql
update instructor
set salary = case
                when salary <= 100000 then salary * 1.05
                else salary * 1.03
             end;
```

**Note**: Insertion and update can be aided with a `select` clause which will be
explained later.

In case that we need to delete all entries in the relation, we can execute the
command `delete from {relation}` or with `where` clause if we want to delete
only those that meet the condition specified. If the relation should be deleted
instead, use the command `drop table {relation}` instead. To alter the attribute
(column) in the relation, we can utilise the command `alter table`, show case in
the following codes for different purposes:

```sql
-- add attribute gender with type char of size of 1 to the relation instructor
alter table instructor add gender char(1);
-- drop the attribute salary from the relation instructor
alter table instructor drop salary;
```

Querying on one or more relation can be done with the command `select`, `from`,
and `where`. By default, `select` removes duplicate entries. This can be
overturned with a specifier as `select all`. Each attribute in the `select`
clause can perform individual arithmetic operations such as `+`, `-`, `*`, and
`/`. In the relation schemas in [Relational Model](202302101331.md), we can
query the instructor's name, their belong department's name, and the building
the department reside with the following SQL codes:

```sql
select name, instructor.dept_name, building
from instructor, department
where instructor.dept_name = department.dept_name;
```

**Note**: If there are duplicate names from two different relations, there is a
need to specify the relation as the prefix to the attribute in order to
distinguish the other. This is shown in the above as `dept_name` is prefixed
with `instructor` to avoid calling the same attribute name from the relation
`department`.

Other than `=`, comparison operators such as `<`, `<=`, `>`, `>=`, and `<>` can
be used. In addition, SQL provides logical connectives such as `and`, `or`, and
`not` to be used to express more complex query. Instead of using `=` comparison
operator, we can use `natural join` to join two relations that have the same
value for particular attributes. Otherwise, by simply `select` from two
different tables, it will result in a [Cartesian Product](202204281601.md) that
contains all tuples regardless of duplications. Natural join operation will
result in a new relation that has no duplicate entries. The above codes can be
rewritten as:

```sql
select name, instructor.dept_name, building
from instructor, department
where instructor natural join department;
```

Despite its convenience, `natural join` might erroneously collapse the
attributes that have the same name but different semantic meaning in different
relations. To avoid that, SQL provides `join ... using` command to specify the
attribute to be equated.

```sql
select name, title
from (instructor natural join teaches) join course using (course_id);
```

In some cases, the attributes or the relations should be renamed in order to
display the information properly or able to performed self comparison. The
command `as` can be used for such cases. The following codes shows two cases
when renaming can be useful:

```sql
-- To clarify the attribute's properties
select name as instructor_name, dept_name
from instructor, department
where instructor natural join department;

-- For relation's self comparison
select distinct T.name
from instructor as T, instructor as S
where T.salary > S.salary and S.dept_name = 'Biology';
```

**Note**: `distinct` keyword explicitly tell `select` or other commands to not
duplicate the same values for a single attribute. Although it is by default,
sometimes it is better to specify it explicitly for more clarity or in
aggregation.

To match substrings, we can utilise the special character `%` (match any
substring) and `_` (match a character) in addition of the use of command `like`
to find the patterns in a relation. If, however, such behaviour is not desired
and instead the special character used must be matched, we can escape the
character by specifying the escape character used with the command `escape`. In
SQL:1999 version, `similar to` operations allow more advanced regular expression
for substring matching. The following shows the use case:

```sql
-- Match department names that contains Watson as a substring
select dept_name
from department
where building like '%Watson%';

-- Match the department name Fortune%
select dept_name
from department
where building like 'Fortune\%' escape '\';
```

We can `select` all attributes from a relation with `*`. Furthermore, the
ordering of the table can be manipulated to be ordered in ascending with `asc`
or descending order with `desc` according to an attribute. Multiple attributes
could be specified to be ordered in such way, where the ordering precedence took
from left to the right. The following codes show how it is used:

```sql
select *
from instructor
order by salary desc, name asc;
```

In some cases, the `where` clause can be simplified with tuple comparison
instead of individual comparisons. The following two queries mean the same:

```sql
select name, course_id
from instructor, teaches
where instructor.ID = teaches.ID and dept_name = 'Biology';

select name, course_id
from instructor, teaches
where (instructor.ID, dept_name) = (teaches.ID, 'Biology');
```

Additionally, we can perform [Set](202204281446.md) operations such as `union`,
`intersect`, and `except` (set difference) on two queries to create a new view
of a relation. By default, all set operations remove duplicates in the result.
To retain it, like in `select`, we can specify `all` quantifier to the set
commands. The following codes show how it is done:

```sql
(select course_id
 from section
 where semester = 'Fall' and year = 2009)
intersect
(select course_id
 from section
 where semester = 'Spring' and year = 2010);
```

SQL provides aggregation functions such as `avg` (average), `min` (finding
minimum), `max` (finding maximum), `sum`, and `count` (total number of
instances) that can be applied on attributes (`avg` and `sum` can only be
applied on a collection of numbers). We can improve the query by grouping in
specific attributes instead of applying on the entire relation with the command
`group by`. Together with another command `having` (applying constraints on
those grouped), we can have the following query with highly readable:

```sql
select dept_name, avg(salary) as avg_salary
from instructor
group by dept_name
having avg(salary) > 42000;
```

**Note**: When using `group by`, ensure that any attribute that is not present
in the `group by` clause must appear only inside an aggregated function if it
appears in the `select` clause. Likewise, any attribute that is present in the
`having` clause without being aggregated must appear in the `group by clause.

Nested subqueries are possible in SQL with the keyword `in`, `not in`, `some`
(comparison), `all` (comparison), `exists` (tests presence), `not exists`,
`unique`, and `not unique` in the `where` clause. Basically, treat it like
finding or comparing the constraints put between two sets. The following queries
show some use cases of nested subqueries in `where` clause:

```sql
-- Finding courses that are opened in the Fall 2009 and Spring 2010
select distinct course_id
from section
where semester = 'Fall' and year = 2009 and
      course_id in (select course_id
                    from section
                    where semester = 'Spring' and year = 2010);

-- Finding instructors whose salary is larger than at least one instructor in Biology Department
select name
from instructor
where salary > some(select salary
                    from nistructor
                    where dept_name = 'Biology');

-- Finding courses that are offered at most once in 2009
select T.course_id
from course as T
where unique (select R.course_id
              from section as R
              where T.course_id = R.course_id and
                    R.year = 2009);
```

Subqueries are also possible in `from` clause, though with the limitation that
it can't access the outer scope's variable. SQL:2003, however, allows such
operation to the subqueries that are prefixed with the keyword `lateral`, but it
is not highly adopted by other SQL vendors. The subqueries in `from` can be
renamed using `as` command. Moreover, subqueries are also possible in `select`
clause, but with the condition that the generated relation can have only one
tuple containing a single attribute (termed *scalar subqueries*).

We generate a temporary relation with the `with` command in which only available
to the query next to the clause. Any aggregation functions or clauses can be
applied to this temporary relation. For example:

```sql
with max_budget(value) as
    (select max(budget)
     from department)
select budget
from department, max_budget
where department.budget = max_budget.value;
```
